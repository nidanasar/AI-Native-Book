"use strict";(globalThis.webpackChunkhackathon_text_book=globalThis.webpackChunkhackathon_text_book||[]).push([[5095],{5310:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"module-2-digital-twin/physics-simulation-gazebo","title":"Chapter 2: Physics Simulation with Gazebo","description":"Learn how to set up Gazebo for physics simulation with ROS 2 humanoid robots","source":"@site/docs/module-2-digital-twin/02-physics-simulation-gazebo.md","sourceDirName":"module-2-digital-twin","slug":"/module-2-digital-twin/physics-simulation-gazebo","permalink":"/docs/module-2-digital-twin/physics-simulation-gazebo","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-2-digital-twin/02-physics-simulation-gazebo.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"Chapter 2: Physics Simulation with Gazebo","description":"Learn how to set up Gazebo for physics simulation with ROS 2 humanoid robots"},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 1: Introduction to Digital Twins in Robotics","permalink":"/docs/module-2-digital-twin/introduction-digital-twins"},"next":{"title":"Chapter 3: Simulating Sensors for Humanoid Robots","permalink":"/docs/module-2-digital-twin/simulating-sensors"}}');var s=i(4848),o=i(8453);const t={sidebar_position:2,title:"Chapter 2: Physics Simulation with Gazebo",description:"Learn how to set up Gazebo for physics simulation with ROS 2 humanoid robots"},l="Physics Simulation with Gazebo",a={},d=[{value:"Introduction to Gazebo",id:"introduction-to-gazebo",level:2},{value:"Gazebo Architecture",id:"gazebo-architecture",level:3},{value:"ROS 2 Integration via ros_gz_bridge",id:"ros-2-integration-via-ros_gz_bridge",level:3},{value:"Installing Gazebo with ROS 2",id:"installing-gazebo-with-ros-2",level:3},{value:"Creating Simulation Worlds",id:"creating-simulation-worlds",level:2},{value:"SDF vs URDF",id:"sdf-vs-urdf",level:3},{value:"Basic World Structure",id:"basic-world-structure",level:3},{value:"Adding Objects to the World",id:"adding-objects-to-the-world",level:3},{value:"World Files for Humanoid Testing",id:"world-files-for-humanoid-testing",level:3},{value:"Spawning Your Robot",id:"spawning-your-robot",level:2},{value:"Method 1: Spawn via ROS 2 Service",id:"method-1-spawn-via-ros-2-service",level:3},{value:"Method 2: Include in World File",id:"method-2-include-in-world-file",level:3},{value:"Launch File for Complete Setup",id:"launch-file-for-complete-setup",level:3},{value:"Verifying the Spawn",id:"verifying-the-spawn",level:3},{value:"Physics Properties and Dynamics",id:"physics-properties-and-dynamics",level:2},{value:"Gravity",id:"gravity",level:3},{value:"Friction",id:"friction",level:3},{value:"Inertia",id:"inertia",level:3},{value:"Physics Engine Options",id:"physics-engine-options",level:3},{value:"Timestep and Real-Time Factor",id:"timestep-and-real-time-factor",level:3},{value:"Controlling Simulated Joints",id:"controlling-simulated-joints",level:2},{value:"Joint State Publisher",id:"joint-state-publisher",level:3},{value:"Joint Position Controller",id:"joint-position-controller",level:3},{value:"ros2_control Integration",id:"ros2_control-integration",level:3},{value:"Observing Behavior",id:"observing-behavior",level:3},{value:"Summary",id:"summary",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"physics-simulation-with-gazebo",children:"Physics Simulation with Gazebo"})}),"\n",(0,s.jsxs)(n.admonition,{title:"Learning Objectives",type:"info",children:[(0,s.jsx)(n.p,{children:"By the end of this chapter, you will be able to:"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Set up a Gazebo simulation environment integrated with ROS 2"}),"\n",(0,s.jsx)(n.li,{children:"Create simulation worlds using SDF (Simulation Description Format)"}),"\n",(0,s.jsx)(n.li,{children:"Load and spawn URDF robot models into Gazebo"}),"\n",(0,s.jsx)(n.li,{children:"Configure physics properties and observe realistic dynamics"}),"\n",(0,s.jsx)(n.li,{children:"Control simulated joints through ROS 2 interfaces"}),"\n"]})]}),"\n",(0,s.jsx)(n.h2,{id:"introduction-to-gazebo",children:"Introduction to Gazebo"}),"\n",(0,s.jsxs)(n.p,{children:["In Chapter 1, you learned that digital twins let robots rehearse actions safely. Now we'll set up ",(0,s.jsx)(n.strong,{children:"Gazebo"}),"\u2014the physics simulator that makes that rehearsal possible. Gazebo is to your robot what a mental practice space is to an athlete: a place to try movements, make mistakes, and refine techniques without real-world consequences."]}),"\n",(0,s.jsx)(n.h3,{id:"gazebo-architecture",children:"Gazebo Architecture"}),"\n",(0,s.jsxs)(n.p,{children:['Modern Gazebo (also called "Ignition Gazebo" or "New Gazebo") is a complete rewrite of the classic Gazebo simulator. If you see references to "Gazebo Classic" or "gazebo11," those refer to the older version. This textbook uses ',(0,s.jsx)(n.strong,{children:"Gazebo Fortress"})," (paired with ROS 2 Humble) or ",(0,s.jsx)(n.strong,{children:"Gazebo Harmonic"})," (paired with ROS 2 Iron/Jazzy)."]}),"\n",(0,s.jsx)(n.p,{children:"Gazebo consists of several components:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502                     GAZEBO SIMULATOR                         \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502   GUI Client    \u2502  Physics Engine \u2502    Sensor Plugins       \u2502\r\n\u2502   (gz gui)      \u2502  (DART/ODE)     \u2502  (cameras, LiDAR, etc.) \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502                    Gazebo Transport                          \u2502\r\n\u2502            (internal message passing system)                 \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502                       gz sim                                 \u2502\r\n\u2502             (simulation server - the core)                   \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,s.jsx)(n.p,{children:"Key components:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"gz sim"}),": The simulation server that runs physics and manages the world"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Physics Engine"}),": Computes forces, collisions, and motion (typically DART)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Sensor Plugins"}),": Generate simulated sensor data (covered in Chapter 3)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"GUI Client"}),": Visualization interface for watching the simulation"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"ros-2-integration-via-ros_gz_bridge",children:"ROS 2 Integration via ros_gz_bridge"}),"\n",(0,s.jsxs)(n.p,{children:["Gazebo has its own transport system, but we want to use ROS 2 topics. The ",(0,s.jsx)(n.strong,{children:"ros_gz_bridge"})," package translates between them:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502   ROS 2     \u2502    ros_gz_bridge         \u2502   Gazebo    \u2502\r\n\u2502   Node      \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502   Plugin    \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n      \u2502                                         \u2502\r\n      \u2502  /cmd_vel (ROS 2 topic)                \u2502  gz transport\r\n      \u2502  /joint_states (ROS 2 topic)           \u2502  (internal)\r\n      \u25bc                                         \u25bc\r\nYour control code                        Physics simulation\n"})}),"\n",(0,s.jsx)(n.p,{children:"This bridge means your ROS 2 code doesn't know (or care) whether it's talking to a real robot or a simulated one. The same code works for both\u2014exactly as the middleware abstraction intended."}),"\n",(0,s.jsx)(n.admonition,{title:"Key Insight",type:"tip",children:(0,s.jsx)(n.p,{children:'Think of ros_gz_bridge as a translator between two languages. Your robot "speaks" ROS 2, Gazebo "speaks" gz transport, and the bridge ensures they understand each other.'})}),"\n",(0,s.jsx)(n.h3,{id:"installing-gazebo-with-ros-2",children:"Installing Gazebo with ROS 2"}),"\n",(0,s.jsx)(n.p,{children:"For ROS 2 Humble, install Gazebo Fortress:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Install Gazebo Fortress and ROS 2 integration packages\r\nsudo apt install ros-humble-ros-gz\r\n\r\n# This installs:\r\n# - gz-fortress (the simulator)\r\n# - ros_gz_bridge (ROS 2 <-> Gazebo bridge)\r\n# - ros_gz_sim (launch file helpers)\n"})}),"\n",(0,s.jsx)(n.p,{children:"For ROS 2 Iron or Jazzy, install Gazebo Harmonic:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"sudo apt install ros-iron-ros-gz  # or ros-jazzy-ros-gz\n"})}),"\n",(0,s.jsx)(n.p,{children:"Verify your installation:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Check Gazebo version\r\ngz sim --version\r\n\r\n# Start an empty simulation\r\ngz sim empty.sdf\n"})}),"\n",(0,s.jsx)(n.h2,{id:"creating-simulation-worlds",children:"Creating Simulation Worlds"}),"\n",(0,s.jsxs)(n.p,{children:["A Gazebo ",(0,s.jsx)(n.strong,{children:"world"})," defines the environment where your robot operates. Worlds are described in ",(0,s.jsx)(n.strong,{children:"SDF (Simulation Description Format)"}),"\u2014an XML format similar to URDF but designed for entire environments, not just robots."]}),"\n",(0,s.jsx)(n.h3,{id:"sdf-vs-urdf",children:"SDF vs URDF"}),"\n",(0,s.jsx)(n.p,{children:"You already know URDF from Module 1. Here's how SDF differs:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Aspect"}),(0,s.jsx)(n.th,{children:"URDF"}),(0,s.jsx)(n.th,{children:"SDF"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Purpose"}),(0,s.jsx)(n.td,{children:"Robot description"}),(0,s.jsx)(n.td,{children:"World + robot description"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Scope"}),(0,s.jsx)(n.td,{children:"Single robot model"}),(0,s.jsx)(n.td,{children:"Entire simulation environment"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Features"}),(0,s.jsx)(n.td,{children:"Links, joints, sensors"}),(0,s.jsx)(n.td,{children:"Physics settings, lighting, multiple models"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"ROS Integration"}),(0,s.jsx)(n.td,{children:"Native"}),(0,s.jsx)(n.td,{children:"Via conversion or direct loading"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"SDF is a superset\u2014it can contain URDF-like robot models plus environmental elements."}),"\n",(0,s.jsx)(n.h3,{id:"basic-world-structure",children:"Basic World Structure"}),"\n",(0,s.jsx)(n.p,{children:"Here's a minimal world file:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0" ?>\r\n<sdf version="1.8">\r\n  <world name="simple_world">\r\n\r\n    \x3c!-- Physics configuration --\x3e\r\n    <physics name="default_physics" type="dart">\r\n      <max_step_size>0.001</max_step_size>\r\n      <real_time_factor>1.0</real_time_factor>\r\n    </physics>\r\n\r\n    \x3c!-- Lighting --\x3e\r\n    <light type="directional" name="sun">\r\n      <cast_shadows>true</cast_shadows>\r\n      <pose>0 0 10 0 0 0</pose>\r\n      <diffuse>0.8 0.8 0.8 1</diffuse>\r\n      <specular>0.2 0.2 0.2 1</specular>\r\n      <direction>-0.5 0.1 -0.9</direction>\r\n    </light>\r\n\r\n    \x3c!-- Ground plane --\x3e\r\n    <model name="ground_plane">\r\n      <static>true</static>\r\n      <link name="link">\r\n        <collision name="collision">\r\n          <geometry>\r\n            <plane>\r\n              <normal>0 0 1</normal>\r\n              <size>100 100</size>\r\n            </plane>\r\n          </geometry>\r\n        </collision>\r\n        <visual name="visual">\r\n          <geometry>\r\n            <plane>\r\n              <normal>0 0 1</normal>\r\n              <size>100 100</size>\r\n            </plane>\r\n          </geometry>\r\n          <material>\r\n            <ambient>0.8 0.8 0.8 1</ambient>\r\n            <diffuse>0.8 0.8 0.8 1</diffuse>\r\n          </material>\r\n        </visual>\r\n      </link>\r\n    </model>\r\n\r\n  </world>\r\n</sdf>\n'})}),"\n",(0,s.jsx)(n.p,{children:"Key elements:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"<physics>"})}),": Configures the physics engine (timestep, real-time factor)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"<light>"})}),": Adds illumination for rendering"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"<model>"})}),": Defines objects in the world (ground plane, obstacles, robots)"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"adding-objects-to-the-world",children:"Adding Objects to the World"}),"\n",(0,s.jsx)(n.p,{children:"You can add obstacles for your robot to interact with:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'\x3c!-- A box obstacle --\x3e\r\n<model name="box_obstacle">\r\n  <pose>2 0 0.5 0 0 0</pose>  \x3c!-- x y z roll pitch yaw --\x3e\r\n  <link name="link">\r\n    <inertial>\r\n      <mass>10.0</mass>\r\n      <inertia>\r\n        <ixx>0.83</ixx><iyy>0.83</iyy><izz>0.83</izz>\r\n      </inertia>\r\n    </inertial>\r\n    <collision name="collision">\r\n      <geometry>\r\n        <box><size>1 1 1</size></box>\r\n      </geometry>\r\n    </collision>\r\n    <visual name="visual">\r\n      <geometry>\r\n        <box><size>1 1 1</size></box>\r\n      </geometry>\r\n      <material>\r\n        <ambient>0.3 0.3 0.8 1</ambient>\r\n      </material>\r\n    </visual>\r\n  </link>\r\n</model>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"world-files-for-humanoid-testing",children:"World Files for Humanoid Testing"}),"\n",(0,s.jsx)(n.p,{children:"For humanoid robots, useful world configurations include:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"World Type"}),(0,s.jsx)(n.th,{children:"Description"}),(0,s.jsx)(n.th,{children:"Use Case"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Flat ground"}),(0,s.jsx)(n.td,{children:"Simple plane"}),(0,s.jsx)(n.td,{children:"Basic standing/walking"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Stairs"}),(0,s.jsx)(n.td,{children:"Step sequence"}),(0,s.jsx)(n.td,{children:"Stair climbing tests"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Uneven terrain"}),(0,s.jsx)(n.td,{children:"Bumps and slopes"}),(0,s.jsx)(n.td,{children:"Balance testing"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Indoor room"}),(0,s.jsx)(n.td,{children:"Walls, furniture"}),(0,s.jsx)(n.td,{children:"Navigation testing"})]})]})]}),"\n",(0,s.jsx)(n.admonition,{title:"Common Mistake",type:"warning",children:(0,s.jsx)(n.p,{children:"Don't forget to add gravity! Without the physics plugin or proper configuration, your robot will float. The default DART physics engine includes Earth gravity (-9.81 m/s\xb2 in Z)."})}),"\n",(0,s.jsx)(n.h2,{id:"spawning-your-robot",children:"Spawning Your Robot"}),"\n",(0,s.jsx)(n.p,{children:"With a world ready, the next step is adding your robot. Gazebo can load URDF models directly or convert them to SDF."}),"\n",(0,s.jsx)(n.h3,{id:"method-1-spawn-via-ros-2-service",children:"Method 1: Spawn via ROS 2 Service"}),"\n",(0,s.jsxs)(n.p,{children:["The recommended approach uses the ",(0,s.jsx)(n.code,{children:"ros_gz_sim"})," package:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'# Terminal 1: Start Gazebo with ROS 2 bridge\r\nros2 launch ros_gz_sim gz_sim.launch.py gz_args:="empty.sdf"\r\n\r\n# Terminal 2: Spawn your robot\r\nros2 run ros_gz_sim create \\\r\n    -name simple_humanoid \\\r\n    -topic robot_description \\\r\n    -z 1.0\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This spawns a robot from the ",(0,s.jsx)(n.code,{children:"/robot_description"})," topic (published by ",(0,s.jsx)(n.code,{children:"robot_state_publisher"}),") at height z=1.0 meters."]}),"\n",(0,s.jsx)(n.h3,{id:"method-2-include-in-world-file",children:"Method 2: Include in World File"}),"\n",(0,s.jsx)(n.p,{children:"You can include the robot directly in your SDF world:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:"<include>\r\n  <uri>model://simple_humanoid</uri>\r\n  <pose>0 0 1.0 0 0 0</pose>\r\n</include>\n"})}),"\n",(0,s.jsx)(n.p,{children:"This requires your robot model to be in Gazebo's model path."}),"\n",(0,s.jsx)(n.h3,{id:"launch-file-for-complete-setup",children:"Launch File for Complete Setup"}),"\n",(0,s.jsx)(n.p,{children:"A typical launch file combines everything:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"from launch import LaunchDescription\r\nfrom launch.actions import IncludeLaunchDescription\r\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\r\nfrom launch_ros.actions import Node\r\nfrom ament_index_python.packages import get_package_share_directory\r\nimport os\r\n\r\ndef generate_launch_description():\r\n    pkg_ros_gz_sim = get_package_share_directory('ros_gz_sim')\r\n\r\n    # Path to your URDF\r\n    urdf_file = os.path.join(\r\n        get_package_share_directory('my_humanoid_description'),\r\n        'urdf', 'simple_humanoid.urdf'\r\n    )\r\n\r\n    with open(urdf_file, 'r') as f:\r\n        robot_description = f.read()\r\n\r\n    # Path to your world file\r\n    world_file = os.path.join(\r\n        get_package_share_directory('my_humanoid_gazebo'),\r\n        'worlds', 'simple_world.sdf'\r\n    )\r\n\r\n    return LaunchDescription([\r\n        # Start Gazebo\r\n        IncludeLaunchDescription(\r\n            PythonLaunchDescriptionSource(\r\n                os.path.join(pkg_ros_gz_sim, 'launch', 'gz_sim.launch.py')\r\n            ),\r\n            launch_arguments={'gz_args': world_file}.items(),\r\n        ),\r\n\r\n        # Publish robot description\r\n        Node(\r\n            package='robot_state_publisher',\r\n            executable='robot_state_publisher',\r\n            parameters=[{'robot_description': robot_description}],\r\n        ),\r\n\r\n        # Spawn robot in Gazebo\r\n        Node(\r\n            package='ros_gz_sim',\r\n            executable='create',\r\n            arguments=[\r\n                '-name', 'simple_humanoid',\r\n                '-topic', 'robot_description',\r\n                '-z', '1.0',\r\n            ],\r\n            output='screen',\r\n        ),\r\n\r\n        # Bridge between Gazebo and ROS 2\r\n        Node(\r\n            package='ros_gz_bridge',\r\n            executable='parameter_bridge',\r\n            arguments=[\r\n                '/clock@rosgraph_msgs/msg/Clock[gz.msgs.Clock',\r\n                '/joint_states@sensor_msgs/msg/JointState[gz.msgs.Model',\r\n            ],\r\n            output='screen',\r\n        ),\r\n    ])\n"})}),"\n",(0,s.jsx)(n.h3,{id:"verifying-the-spawn",children:"Verifying the Spawn"}),"\n",(0,s.jsx)(n.p,{children:"After launching, verify your robot loaded correctly:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# List models in Gazebo\r\ngz model --list\r\n\r\n# Check ROS 2 topics\r\nros2 topic list | grep joint\r\n\r\n# Echo joint states\r\nros2 topic echo /joint_states\n"})}),"\n",(0,s.jsx)(n.p,{children:"You should see your robot in the Gazebo GUI and joint states publishing on ROS 2 topics."}),"\n",(0,s.jsx)(n.h2,{id:"physics-properties-and-dynamics",children:"Physics Properties and Dynamics"}),"\n",(0,s.jsx)(n.p,{children:"Gazebo simulates physics based on properties you define. Understanding these helps you create realistic simulations."}),"\n",(0,s.jsx)(n.h3,{id:"gravity",children:"Gravity"}),"\n",(0,s.jsx)(n.p,{children:"By default, Gazebo applies Earth gravity (9.81 m/s\xb2 downward). You can modify this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<physics name="default_physics" type="dart">\r\n  <gravity>0 0 -9.81</gravity>  \x3c!-- Earth gravity --\x3e\r\n  \x3c!-- For Moon: <gravity>0 0 -1.62</gravity> --\x3e\r\n  \x3c!-- For Mars: <gravity>0 0 -3.71</gravity> --\x3e\r\n</physics>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"friction",children:"Friction"}),"\n",(0,s.jsx)(n.p,{children:"Friction determines how surfaces interact. Configure it in collision elements:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<collision name="foot_collision">\r\n  <geometry>\r\n    <box><size>0.15 0.08 0.02</size></box>\r\n  </geometry>\r\n  <surface>\r\n    <friction>\r\n      <ode>\r\n        <mu>0.8</mu>      \x3c!-- Friction coefficient (0-1+) --\x3e\r\n        <mu2>0.8</mu2>    \x3c!-- Secondary friction --\x3e\r\n      </ode>\r\n    </friction>\r\n  </surface>\r\n</collision>\n'})}),"\n",(0,s.jsx)(n.p,{children:'Higher friction values (closer to 1.0) make surfaces "grippy"\u2014important for humanoid feet!'}),"\n",(0,s.jsx)(n.h3,{id:"inertia",children:"Inertia"}),"\n",(0,s.jsx)(n.p,{children:"Inertia determines how objects resist rotational acceleration. From Module 1, you know URDF includes inertia tensors:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<inertial>\r\n  <mass value="5.0"/>\r\n  <inertia\r\n    ixx="0.1" ixy="0" ixz="0"\r\n    iyy="0.1" iyz="0"\r\n    izz="0.05"/>\r\n</inertial>\n'})}),"\n",(0,s.jsx)(n.admonition,{title:"Common Issue",type:"warning",children:(0,s.jsxs)(n.p,{children:["Incorrect inertia values cause unstable simulation. If your robot vibrates or explodes, check inertia values. A good approximation for a box: ",(0,s.jsx)(n.code,{children:"I = (1/12) \xd7 mass \xd7 (width\xb2 + height\xb2)"}),"."]})}),"\n",(0,s.jsx)(n.h3,{id:"physics-engine-options",children:"Physics Engine Options"}),"\n",(0,s.jsx)(n.p,{children:"Gazebo supports multiple physics engines:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Engine"}),(0,s.jsx)(n.th,{children:"Strengths"}),(0,s.jsx)(n.th,{children:"Best For"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"DART"}),(0,s.jsx)(n.td,{children:"Contact handling, constraints"}),(0,s.jsx)(n.td,{children:"Humanoid robots, manipulation"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"ODE"}),(0,s.jsx)(n.td,{children:"Speed, stability"}),(0,s.jsx)(n.td,{children:"Ground vehicles, simple robots"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Bullet"}),(0,s.jsx)(n.td,{children:"Game-like physics"}),(0,s.jsx)(n.td,{children:"Quick prototyping"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"DART is recommended for humanoid robots due to superior contact handling\u2014crucial for walking and balance."}),"\n",(0,s.jsx)(n.h3,{id:"timestep-and-real-time-factor",children:"Timestep and Real-Time Factor"}),"\n",(0,s.jsx)(n.p,{children:"Two important physics parameters:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<physics name="default_physics" type="dart">\r\n  <max_step_size>0.001</max_step_size>   \x3c!-- 1ms timestep --\x3e\r\n  <real_time_factor>1.0</real_time_factor> \x3c!-- 1.0 = real-time --\x3e\r\n</physics>\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"max_step_size"}),": Smaller = more accurate but slower. 1ms works well for humanoids."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"real_time_factor"}),": Set greater than 1.0 for faster-than-real-time (useful for training), less than 1.0 for slow motion."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"controlling-simulated-joints",children:"Controlling Simulated Joints"}),"\n",(0,s.jsx)(n.p,{children:"With your robot spawned and physics configured, you need to control it. Gazebo integrates with ROS 2 control systems through plugins."}),"\n",(0,s.jsx)(n.h3,{id:"joint-state-publisher",children:"Joint State Publisher"}),"\n",(0,s.jsx)(n.p,{children:"To read joint positions from Gazebo, use the JointStatePub plugin:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Add to your robot model in SDF or URDF (Gazebo-specific) --\x3e\r\n<gazebo>\r\n  <plugin filename="gz-sim-joint-state-publisher-system"\r\n          name="gz::sim::systems::JointStatePublisher">\r\n    <topic>joint_states</topic>\r\n  </plugin>\r\n</gazebo>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This publishes joint positions, velocities, and efforts to a Gazebo topic, which ",(0,s.jsx)(n.code,{children:"ros_gz_bridge"})," forwards to ROS 2."]}),"\n",(0,s.jsx)(n.h3,{id:"joint-position-controller",children:"Joint Position Controller"}),"\n",(0,s.jsx)(n.p,{children:"To command joint positions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<gazebo>\r\n  <plugin filename="gz-sim-joint-position-controller-system"\r\n          name="gz::sim::systems::JointPositionController">\r\n    <joint_name>left_shoulder_joint</joint_name>\r\n    <topic>left_shoulder_cmd</topic>\r\n    <p_gain>100</p_gain>\r\n    <i_gain>0.1</i_gain>\r\n    <d_gain>10</d_gain>\r\n  </plugin>\r\n</gazebo>\n'})}),"\n",(0,s.jsx)(n.p,{children:"Then send commands via ROS 2 (after bridging):"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'ros2 topic pub /left_shoulder_cmd std_msgs/msg/Float64 "data: 0.5"\n'})}),"\n",(0,s.jsx)(n.h3,{id:"ros2_control-integration",children:"ros2_control Integration"}),"\n",(0,s.jsxs)(n.p,{children:["For complex robots, ",(0,s.jsx)(n.strong,{children:"ros2_control"})," provides a standardized control framework:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'\x3c!-- In your URDF --\x3e\r\n<ros2_control name="GazeboSimSystem" type="system">\r\n  <hardware>\r\n    <plugin>gz_ros2_control/GazeboSimSystem</plugin>\r\n  </hardware>\r\n  <joint name="left_shoulder_joint">\r\n    <command_interface name="position"/>\r\n    <state_interface name="position"/>\r\n    <state_interface name="velocity"/>\r\n  </joint>\r\n  \x3c!-- ... more joints ... --\x3e\r\n</ros2_control>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This integrates with ROS 2 controllers like ",(0,s.jsx)(n.code,{children:"joint_trajectory_controller"})," for smooth motion:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Load and configure controllers\r\nros2 control load_controller joint_trajectory_controller\r\nros2 control set_controller_state joint_trajectory_controller active\n"})}),"\n",(0,s.jsx)(n.h3,{id:"observing-behavior",children:"Observing Behavior"}),"\n",(0,s.jsx)(n.p,{children:"Monitor your simulation through various tools:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Watch joint states in terminal\r\nros2 topic echo /joint_states\r\n\r\n# Visualize in RViz\r\nros2 run rviz2 rviz2\r\n\r\n# Plot joint positions over time\r\nros2 run rqt_plot rqt_plot /joint_states/position[0]\n"})}),"\n",(0,s.jsx)(n.p,{children:"The Gazebo GUI also shows real-time information:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Select your robot model"}),"\n",(0,s.jsx)(n.li,{children:"View \u2192 Component Inspector shows pose, velocity, forces"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(n.p,{children:"In this chapter, you learned how to create physics simulations for humanoid robots using Gazebo:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key Concepts:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Gazebo"})," is a physics simulator that integrates with ROS 2 via ros_gz_bridge"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"New Gazebo (Fortress/Harmonic) replaces Gazebo Classic"}),"\n",(0,s.jsx)(n.li,{children:"Uses DART physics engine for accurate humanoid simulation"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"World files (SDF)"})," define the simulation environment"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Configure physics, lighting, ground, obstacles"}),"\n",(0,s.jsx)(n.li,{children:"SDF is similar to URDF but for entire worlds"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Spawning robots"})," can be done via:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["ROS 2 service (",(0,s.jsx)(n.code,{children:"ros_gz_sim create"}),")"]}),"\n",(0,s.jsx)(n.li,{children:"Direct inclusion in world file"}),"\n",(0,s.jsx)(n.li,{children:"Launch files for complete setup"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Physics properties"})," affect simulation realism:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Gravity, friction, inertia"}),"\n",(0,s.jsx)(n.li,{children:"Timestep and real-time factor"}),"\n",(0,s.jsx)(n.li,{children:"Choose appropriate physics engine (DART for humanoids)"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Joint control"})," through Gazebo plugins:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"JointStatePublisher for reading states"}),"\n",(0,s.jsx)(n.li,{children:"JointPositionController for commanding"}),"\n",(0,s.jsx)(n.li,{children:"ros2_control integration for complex behaviors"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"The Virtual Rehearsal Continues:"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Concept"}),(0,s.jsx)(n.th,{children:"Analogy"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Gazebo world"}),(0,s.jsx)(n.td,{children:'The mental "stage" where rehearsal happens'})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Physics engine"}),(0,s.jsx)(n.td,{children:"The brain's internal model of how things move"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Spawning robot"}),(0,s.jsx)(n.td,{children:"Imagining yourself in the scenario"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Joint control"}),(0,s.jsx)(n.td,{children:"Mentally commanding your body to move"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"What's Next:"})}),"\n",(0,s.jsx)(n.p,{children:"Your robot can now move in simulation, but it's blind and deaf\u2014it has no sensors. In Chapter 3, we'll add simulated LiDAR, cameras, and IMUs so your robot can perceive its virtual environment, completing the sensory feedback loop that makes digital twins truly useful for developing perception and control algorithms."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.admonition,{title:"Next Chapter",type:"tip",children:(0,s.jsxs)(n.p,{children:["Continue to ",(0,s.jsx)(n.a,{href:"./simulating-sensors",children:"Chapter 3: Simulating Sensors"})," to learn how to add LiDAR, depth cameras, and IMUs to your simulated humanoid."]})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>l});var r=i(6540);const s={},o=r.createContext(s);function t(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);